<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>A letter for you</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Dancing+Script:wght@600&family=Montserrat:wght@300;500&display=swap');

    /* FIXED: Added height: 100% to ensure gradient fills screen */
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
    }

    body {
      overflow: hidden;
      /* FIXED: Darker, cooler gradient so white/gold particles are visible */
      background: linear-gradient(to top, #cfd9df 0%, #e2ebf0 100%);
      /* background: linear-gradient(to top, #38085e 0%, #09001c 100%); */
      font-family: 'Montserrat', sans-serif;
      user-select: none;
    }

    #bg-dimmer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #000;
      opacity: 0;
      pointer-events: none;
      z-index: 0;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
      opacity: 0;
      transition: opacity 2s ease;
    }

    #intro-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      z-index: 10;
    }

    .intro-text {
      font-family: 'Dancing Script', cursive;
      font-size: 4rem;
      color: #333;
      opacity: 0;
      transition: opacity 2s ease-in-out;
      text-align: center;
    }

    #instructions {
      position: absolute;
      bottom: 30px;
      width: 100%;
      text-align: center;
      color: #aaa;
      font-size: 0.9rem;
      opacity: 0;
      transition: opacity 1s;
      pointer-events: none;
      letter-spacing: 2px;
      z-index: 5;
    }
  </style>
</head>
<body>

<div id="bg-dimmer"></div>
<div id="intro-overlay">
  <div class="intro-text" id="message">Happy Birthday<br>My Love</div>
</div>

<div id="instructions">Click to open</div>
<div id="canvas-container"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

<script>
  // --- CONFIGURATION ---
  const PARTNER_NAME = "Cici";
  const INTRO_TEXT = `Happy Birthday<br>${PARTNER_NAME} :)`;
  const INNER_MESSAGE = "I wish I could be there\nto give this to you.\n\nLove, Lulu";

  // --- ASSET URLs ---
  const FRONT_IMG_URL = "/cici.png";
  const INSIDE_IMG_URL = "/letter.png";

  // --- STATE MANAGEMENT ---
  const STATE = {
    INTRO: 0,
    ENVELOPE_WAITING: 1,
    OPENING_SEQUENCE: 2,
    CARD_CLOSED_IDLE: 5,
    CARD_OPENING: 6,
    CARD_OPEN_IDLE: 7,
    CARD_CLOSING: 8
  };
  let currentState = STATE.INTRO;

  // --- SCENE SETUP ---
  const container = document.getElementById('canvas-container');
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 15);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  renderer.toneMapping = THREE.LinearToneMapping;
  renderer.toneMappingExposure = 0.85;
  renderer.outputEncoding = THREE.sRGBEncoding;

  container.appendChild(renderer.domElement);

  // --- LIGHTING ---
  const hemiLight = new THREE.HemisphereLight(0xffffff, 0xeedddd, 0.6);
  scene.add(hemiLight);

  const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
  dirLight.position.set(5, 10, 7);
  dirLight.castShadow = true;

  dirLight.shadow.mapSize.width = 2048;
  dirLight.shadow.mapSize.height = 2048;
  dirLight.shadow.bias = -0.0001;
  dirLight.shadow.radius = 4;
  const d = 8;
  dirLight.shadow.camera.left = -d;
  dirLight.shadow.camera.right = d;
  dirLight.shadow.camera.top = d;
  dirLight.shadow.camera.bottom = -d;

  scene.add(dirLight);

  const pointLight = new THREE.PointLight(0xffd700, 0.4);
  pointLight.position.set(-5, 5, 20);
  scene.add(pointLight);

  // --- TEXTURES ---
  // UPDATED: Now creates a 4-pointed star shape
  function createSparkleTexture() {
    const canvas = document.createElement('canvas');
    const size = 64;
    canvas.width = size; canvas.height = size;
    const ctx = canvas.getContext('2d');
    const center = size / 2;
    const outerRadius = size * 0.4;
    const innerRadius = size * 0.1;
    const spikes = 4;

    let rot = Math.PI / 2 * 3;
    let x = center;
    let y = center;
    let step = Math.PI / spikes;

    ctx.beginPath();
    ctx.moveTo(center, center - outerRadius);
    for (let i = 0; i < spikes; i++) {
      x = center + Math.cos(rot) * outerRadius;
      y = center + Math.sin(rot) * outerRadius;
      ctx.lineTo(x, y);
      rot += step;

      x = center + Math.cos(rot) * innerRadius;
      y = center + Math.sin(rot) * innerRadius;
      ctx.lineTo(x, y);
      rot += step;
    }
    ctx.lineTo(center, center - outerRadius);
    ctx.closePath();

    // Create a radial gradient for the star to make it glow
    const grad = ctx.createRadialGradient(center, center, innerRadius, center, center, outerRadius);
    grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
    grad.addColorStop(0.5, 'rgba(255, 255, 255, 0.8)');
    grad.addColorStop(1, 'rgba(255, 255, 255, 0)');

    ctx.fillStyle = grad;
    ctx.fill();

    return new THREE.CanvasTexture(canvas);
  }

  // God Ray Texture for the loot effect
  function createRayTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 256;
    const ctx = canvas.getContext('2d');

    const grad = ctx.createLinearGradient(0, 0, 0, 256);
    grad.addColorStop(0, 'rgba(255, 255, 255, 0)');
    grad.addColorStop(0.1, 'rgba(255, 255, 255, 0)');
    // Increased opacity here to make rays more visible
    grad.addColorStop(0.5, 'rgba(255, 220, 100, 0.6)');
    grad.addColorStop(1, 'rgba(255, 255, 255, 0.9)');

    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 64, 256);

    const maskGrad = ctx.createLinearGradient(0, 0, 64, 0);
    maskGrad.addColorStop(0, 'rgba(0,0,0,1)');
    maskGrad.addColorStop(0.5, 'rgba(0,0,0,0)');
    maskGrad.addColorStop(1, 'rgba(0,0,0,1)');

    ctx.globalCompositeOperation = 'destination-out';
    ctx.fillStyle = maskGrad;
    ctx.fillRect(0, 0, 64, 256);

    const tex = new THREE.CanvasTexture(canvas);
    return tex;
  }

  function createPaperBumpMap() {
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 512;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#808080';
    ctx.fillRect(0,0,512,512);
    for(let i=0; i<200000; i++) {
      const offset = Math.floor((Math.random() - 0.5) * 60);
      const val = 128 + offset;
      ctx.fillStyle = `rgb(${val},${val},${val})`;
      ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);
    }
    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.repeat.set(4, 4);
    return texture;
  }

  function createTextTexture(text, type = 'front') {
    const canvas = document.createElement('canvas');
    canvas.width = 1024; canvas.height = 1024;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = type === 'front' ? '#ff9a9e' : '#fdfbf7';
    ctx.fillRect(0, 0, 1024, 1024);
    if (type === 'front') {
      ctx.fillStyle = '#fad0c4';
      ctx.beginPath(); ctx.arc(512, 512, 400, 0, Math.PI * 2); ctx.fill();
      ctx.font = 'bold 120px Montserrat';
      ctx.fillStyle = 'white';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText("Happy", 512, 400);
      ctx.fillText("Birthday!", 512, 550);
    } else if (type === 'inside') {
      ctx.font = '50px Dancing Script';
      ctx.fillStyle = '#333';
      ctx.textAlign = 'center'; ctx.textBaseline = 'top';
      const lines = text.split('\n');
      let y = 300;
      lines.forEach(line => { ctx.fillText(line, 512, y); y += 80; });
    } else {
      ctx.fillStyle = '#fdfbf7';
      ctx.fillRect(0,0,1024,1024);
      for(let i=0; i<10000; i++) {
        ctx.fillStyle = `rgba(0,0,0,${Math.random()*0.03})`;
        ctx.fillRect(Math.random()*1024, Math.random()*1024, 2, 2);
      }
    }
    return new THREE.CanvasTexture(canvas);
  }

  function createEnvelopeTexture(type) {
    const canvas = document.createElement('canvas');
    canvas.width = 512; canvas.height = 512;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ece5d5';
    ctx.fillRect(0,0,512,512);
    const tex = new THREE.CanvasTexture(canvas);
    tex.encoding = THREE.sRGBEncoding;
    return tex;
  }

  const loader = new THREE.TextureLoader();
  loader.setCrossOrigin('anonymous');
  const frontTexture = FRONT_IMG_URL ? loader.load(FRONT_IMG_URL) : createTextTexture("", 'front');
  const insideTexture = INSIDE_IMG_URL ? loader.load(INSIDE_IMG_URL) : createTextTexture(INNER_MESSAGE, 'inside');
  const paperTexture = createTextTexture("", 'paper');
  const paperBumpTexture = createPaperBumpMap();
  const sparkleTexture = createSparkleTexture();
  const rayTexture = createRayTexture();

  frontTexture.encoding = THREE.sRGBEncoding;
  insideTexture.encoding = THREE.sRGBEncoding;
  paperTexture.encoding = THREE.sRGBEncoding;

  frontTexture.center.set(0.5, 0.5);
  frontTexture.repeat.x = 1;
  insideTexture.center.set(0.5, 0.5);
  insideTexture.repeat.x = 1;

  frontTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
  frontTexture.minFilter = THREE.LinearFilter;
  frontTexture.magFilter = THREE.LinearFilter;
  frontTexture.generateMipmaps = false;
  frontTexture.needsUpdate = true;
  insideTexture.anisotropy = renderer.capabilities.getMaxAnisotropy();
  insideTexture.minFilter = THREE.LinearFilter;
  insideTexture.magFilter = THREE.LinearFilter;
  insideTexture.generateMipmaps = false;
  insideTexture.needsUpdate = true;

  // --- GROUPS ---
  const groupAll = new THREE.Group();
  scene.add(groupAll);

  const envelopeGroup = new THREE.Group();
  groupAll.add(envelopeGroup);

  const envTexture = createEnvelopeTexture('base');

  function makeEnvMat(tex) {
    return new THREE.MeshStandardMaterial({
      map: tex,
      bumpMap: paperBumpTexture,
      bumpScale: 0.02,
      roughness: 0.8,
      metalness: 0.0,
      side: THREE.DoubleSide
    });
  }

  const edgeMat = new THREE.MeshStandardMaterial({
    color: 0xe0dac0,
    roughness: 1.0,
    metalness: 0.0
  });

  function fixUVs(geometry, scale) {
    const posAttribute = geometry.attributes.position;
    const uvAttribute = geometry.attributes.uv;
    for (let i = 0; i < posAttribute.count; i++) {
      const x = posAttribute.getX(i);
      const y = posAttribute.getY(i);
      const u = (x / scale) + 0.5;
      const v = (y / scale) + 0.5;
      uvAttribute.setXY(i, u, v);
    }
    uvAttribute.needsUpdate = true;
  }

  // --- GEOMETRY: SQUARE ENVELOPE (6.6 x 6.6) ---
  const paperThickness = 0.01;

  // 1. Envelope Back
  const envBack = new THREE.Mesh(new THREE.PlaneGeometry(6.6, 6.6), makeEnvMat(envTexture));
  envBack.position.y = 0;
  envBack.position.z = -0.06;
  envBack.castShadow = true;
  envBack.receiveShadow = false;
  envelopeGroup.add(envBack);

  // 2. Envelope Front (Pocket)
  const pocketShape = new THREE.Shape();
  pocketShape.moveTo(-3.3, 3.3);
  pocketShape.lineTo(0, 0.6);
  pocketShape.lineTo(3.3, 3.3);
  pocketShape.lineTo(3.3, -3.3);
  pocketShape.lineTo(-3.3, -3.3);
  pocketShape.lineTo(-3.3, 3.3);

  // BEVEL ENABLED - Reduced size for subtlety
  const pocketGeo = new THREE.ExtrudeGeometry(pocketShape, {
    depth: paperThickness,
    bevelEnabled: true,
    bevelThickness: 0.02,
    bevelSize: 0.02,
    bevelSegments: 5
  });
  fixUVs(pocketGeo, 6.6);

  const envFront = new THREE.Mesh(pocketGeo, [makeEnvMat(envTexture), edgeMat]);
  envFront.position.z = 0.06;
  envFront.receiveShadow = true;
  envFront.castShadow = true;
  envelopeGroup.add(envFront);

  // 3. Flap
  const flapGroup = new THREE.Group();
  flapGroup.position.y = 3.3;
  flapGroup.position.z = 0.07;
  envelopeGroup.add(flapGroup);

  const flapShape = new THREE.Shape();
  const width = 3.3;
  const height = 3.5;
  flapShape.moveTo(-width, 0);
  flapShape.lineTo(width, 0);
  const tipRadius = 0.4;
  flapShape.lineTo(tipRadius, -height + tipRadius);
  flapShape.quadraticCurveTo(0, -height, -tipRadius, -height + tipRadius);
  flapShape.lineTo(-width, 0);

  // BEVEL ENABLED - Reduced size for subtlety
  const flapGeometry = new THREE.ExtrudeGeometry(flapShape, {
    depth: paperThickness,
    bevelEnabled: true,
    bevelThickness: 0.02,
    bevelSize: 0.02,
    bevelSegments: 5
  });

  // Fix Flap UVs
  const posAttribute = flapGeometry.attributes.position;
  const uvAttribute = flapGeometry.attributes.uv;
  for (let i = 0; i < posAttribute.count; i++) {
    const x = posAttribute.getX(i);
    const y = posAttribute.getY(i);
    const u = (x / 6.6) + 0.5;
    const v = 1.0 + (y / 6.6);
    uvAttribute.setXY(i, u, v);
  }
  uvAttribute.needsUpdate = true;

  const flap = new THREE.Mesh(flapGeometry, [makeEnvMat(envTexture), edgeMat]);
  flap.castShadow = true;
  flapGroup.add(flap);

  // --- FOLDED CARD SETUP ---
  const cardPivotGroup = new THREE.Group();
  groupAll.add(cardPivotGroup);
  cardPivotGroup.position.set(0, 0, 0);

  const cardMasterGroup = new THREE.Group();
  cardPivotGroup.add(cardMasterGroup);
  cardMasterGroup.rotation.y = Math.PI;
  cardMasterGroup.position.set(0, 0, 0);

  const cardW = 5.8;
  const cardH = 5.8;
  const cardThick = 0.03;

  const commonMatProps = {
    color: 0xfaf9f6,
    bumpMap: paperBumpTexture,
    bumpScale: 0.02,
    roughness: 0.95,
    metalness: 0.0,
  };

  const whiteMat = new THREE.MeshStandardMaterial(commonMatProps);

  const frontFaceMat = new THREE.MeshStandardMaterial({
    ...commonMatProps,
    map: frontTexture,
    color: 0xffffff
  });

  const insideFaceMat = new THREE.MeshStandardMaterial({
    ...commonMatProps,
    map: insideTexture,
    color: 0xffffff
  });

  const paperFaceMat = new THREE.MeshStandardMaterial({
    ...commonMatProps,
    map: paperTexture,
    color: 0xffffff
  });

  // 1. Right Panel
  const rightPanelGeo = new THREE.BoxGeometry(cardW, cardH, cardThick);
  const rightMaterials = [whiteMat, whiteMat, whiteMat, whiteMat, insideFaceMat, paperFaceMat];
  const rightPanel = new THREE.Mesh(rightPanelGeo, rightMaterials);
  rightPanel.castShadow = true; rightPanel.receiveShadow = true;
  cardMasterGroup.add(rightPanel);

  // 2. The Spine Hinge
  const hingeGroup = new THREE.Group();
  hingeGroup.position.x = -2.9;
  cardMasterGroup.add(hingeGroup);

  // 3. Left Panel
  const leftPanelGeo = new THREE.BoxGeometry(cardW, cardH, cardThick);
  leftPanelGeo.translate(-cardW/2, 0, 0);
  const leftMaterials = [whiteMat, whiteMat, whiteMat, whiteMat, paperFaceMat, frontFaceMat];
  const leftPanel = new THREE.Mesh(leftPanelGeo, leftMaterials);
  leftPanel.castShadow = true; leftPanel.receiveShadow = true;
  hingeGroup.add(leftPanel);

  // INITIAL STATE: Card is CLOSED.
  hingeGroup.rotation.y = Math.PI - 0.05;


  // --- BURST PARTICLES (Explosion) ---
  const burstParticles = [];
  let spawnedBurstParticles = false;

  function spawnBurstParticle() {
    // Unique material per particle allows unique rotation and opacity
    const mat = new THREE.SpriteMaterial({
      map: sparkleTexture,
      transparent: true,
      opacity: 1.0,
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      rotation: Math.random() * Math.PI * 2 // Random initial rotation
    });

    const sprite = new THREE.Sprite(mat);

    // Random Size - Reduced to look like fine dust
    const size = 0.15 + Math.random() * 0.25;
    sprite.scale.set(size, size, 1);

    // Start Position (Cluster near center)
    // REVERTED: Back to tight cluster (0.5) so the burst originates from the center
    sprite.position.set(
            (Math.random() - 0.5) * 0.5,
            (Math.random() - 0.5) * 0.5,
            0.1 + (Math.random() * 0.2) // Slightly in front
    );

    // Velocity Calculation
    const speed = 0.05 + Math.random() * 0.35; // Varied speed

    // Random Direction Sphere
    let vx = (Math.random() - 0.5) * 2;
    let vy = (Math.random() - 0.5) * 2;
    let vz = 0.3 + Math.random();

    const len = Math.sqrt(vx*vx + vy*vy + vz*vz);

    const vel = new THREE.Vector3(
            (vx / len) * speed,
            (vy / len) * speed,
            (vz / len) * speed
    );

    cardPivotGroup.add(sprite);

    burstParticles.push({
      mesh: sprite,
      vel: vel,
      life: 0,
      maxLife: 1.5 + Math.random() * 1.5
    });
  }


  // --- LOOT RAYS (Continuous Particle System) ---
  const rayGroup = new THREE.Group();
  rayGroup.position.z = -0.2;
  cardPivotGroup.add(rayGroup);

  const rayGeo = new THREE.PlaneGeometry(1, 1);
  rayGeo.translate(0, 0.5, 0);

  const rayParticles = [];
  let raySpawnTimer = 0;
  let lootRaysActive = false;

  function spawnRay() {
    const mat = new THREE.MeshBasicMaterial({
      map: rayTexture,
      transparent: true,
      opacity: 0,
      side: THREE.DoubleSide,
      blending: THREE.AdditiveBlending,
      depthWrite: false
    });
    const mesh = new THREE.Mesh(rayGeo, mat);

    mesh.rotation.z = Math.random() * Math.PI * 2;

    const width = 0.5 + Math.random() * 0.5;
    const length = 8 + Math.random() * 4;

    rayGroup.add(mesh);

    rayParticles.push({
      mesh: mesh,
      life: 0,
      maxLife: 2.0,
      w: width,
      l: length
    });
  }

  function updateLootRays(dt) {
    // 1. Spawning (10 per second)
    // MODIFIED: Only spawn rays if we are NOT reading the card.
    // This clears the background while reading text.
    const isReading = currentState === STATE.CARD_OPENING || currentState === STATE.CARD_OPEN_IDLE;

    if (!isReading) {
      raySpawnTimer += dt;
      const spawnRate = 0.1;
      while(raySpawnTimer > spawnRate) {
        spawnRay();
        raySpawnTimer -= spawnRate;
      }
    }

    // 2. Updating (Always update existing so they fade out naturally/don't freeze)
    for (let i = rayParticles.length - 1; i >= 0; i--) {
      const p = rayParticles[i];
      p.life += dt;

      const n = p.life / p.maxLife;

      if (n >= 1) {
        rayGroup.remove(p.mesh);
        p.mesh.material.dispose();
        rayParticles.splice(i, 1);
        continue;
      }

      const curLen = p.l * Math.pow(n, 0.7);

      let curW = p.w;
      if (n > 0.7) {
        curW = p.w * (1 - (n - 0.7) / 0.3);
      }

      let op = 0;
      if (n < 0.1) op = n * 10;
      else if (n > 0.7) op = 1.0 - ((n - 0.7) / 0.3);
      else op = 1.0;

      p.mesh.scale.set(curW, curLen, 1);
      p.mesh.material.opacity = op * 0.6;
    }

    rayGroup.rotation.z += 0.1 * dt;
  }


  // --- INTERACTION ---
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  let targetRotX = 0, targetRotY = 0;

  function handleInteraction(clientX, clientY) {
    mouse.x = (clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const objectsToTest = [envelopeGroup, cardMasterGroup, ...envelopeGroup.children, ...cardMasterGroup.children];
    const intersects = raycaster.intersectObjects(objectsToTest, true);

    if (intersects.length > 0) {
      if (currentState === STATE.ENVELOPE_WAITING) {
        currentState = STATE.OPENING_SEQUENCE;
        targetRotX = 0; targetRotY = 0;
        playEnvelopeSequence();
      } else if (currentState === STATE.CARD_CLOSED_IDLE) {
        currentState = STATE.CARD_OPENING;
        document.getElementById('instructions').style.opacity = 0;
      } else if (currentState === STATE.CARD_OPEN_IDLE) {
        currentState = STATE.CARD_CLOSING;
      }
    }
  }

  function updateParallax(clientX, clientY, sensitivity = 1.0) {
    const x = (clientX / window.innerWidth) * 2 - 1;
    const y = -(clientY / window.innerHeight) * 2 + 1;
    const allowRotation = currentState === STATE.ENVELOPE_WAITING || currentState >= STATE.CARD_CLOSED_IDLE;
    if (allowRotation) {
      targetRotY = x * 0.2 * sensitivity;
      targetRotX = -y * 0.2 * sensitivity;
    }
  }

  document.addEventListener('mousemove', (e) => { updateParallax(e.clientX, e.clientY, 1.0); });
  document.addEventListener('click', (e) => { handleInteraction(e.clientX, e.clientY); });

  let touchStartX = 0, touchStartY = 0, isDragging = false;
  document.addEventListener('touchstart', (e) => { if(e.touches.length>0){touchStartX=e.touches[0].clientX; touchStartY=e.touches[0].clientY; isDragging=false;} }, {passive: false});
  document.addEventListener('touchmove', (e) => { if(e.touches.length>0){ e.preventDefault(); const x=e.touches[0].clientX, y=e.touches[0].clientY; if(Math.abs(x-touchStartX)>10 || Math.abs(y-touchStartY)>10) isDragging=true; updateParallax(x, y, 2.5);} }, {passive: false});
  document.addEventListener('touchend', (e) => { targetRotY=0; targetRotX=0; if(!isDragging && e.changedTouches.length>0) handleInteraction(e.changedTouches[0].clientX, e.changedTouches[0].clientY); });
  document.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

  // --- SEQUENCES ---
  const textEl = document.getElementById('message');
  textEl.innerHTML = INTRO_TEXT;
  setTimeout(() => textEl.style.opacity = 1, 500);
  setTimeout(() => textEl.style.opacity = 0, 4000);
  setTimeout(() => {
    document.getElementById('intro-overlay').style.display = 'none';
    document.getElementById('canvas-container').style.opacity = 1;
    currentState = STATE.ENVELOPE_WAITING;
    document.getElementById('instructions').innerText = "Click to open";
    document.getElementById('instructions').style.opacity = 1;
  }, 6000);

  function playEnvelopeSequence() {
    document.getElementById('instructions').style.opacity = 0;
    const startRot = flapGroup.rotation.x;
    const startT = Date.now();
    const duration = 300;
    const startZ = flapGroup.position.z;
    const endZ = -0.06;

    const interval = setInterval(() => {
      const p = Math.min((Date.now() - startT) / duration, 1);
      const ease = 1 - Math.pow(1 - p, 4);
      flapGroup.rotation.x = startRot + (Math.PI * ease);
      flapGroup.position.z = startZ + ((endZ - startZ) * ease);
      if (p === 1) { clearInterval(interval); setTimeout(pullCardOut, 300); }
    }, 16);
  }

  function pullCardOut() {
    const startT = Date.now();
    const startY = cardPivotGroup.position.y;
    const endY = 0;
    const duration = 800;
    const interval = setInterval(() => {
      const p = Math.min((Date.now() - startT) / duration, 1);
      const ease = 1 - Math.pow(1 - p, 2);
      cardPivotGroup.position.y = startY + ((endY - startY) * ease);
      if (p === 1) { clearInterval(interval); dropEnvelope(); }
    }, 16);
  }

  function dropEnvelope() {
    const startT = Date.now();
    const startY = envelopeGroup.position.y;
    const endY = -25;
    const duration = 400;
    const interval = setInterval(() => {
      const p = Math.min((Date.now() - startT) / duration, 1);
      const ease = p * p;
      envelopeGroup.position.y = startY + ((endY - startY) * ease);
      if (p === 1) { clearInterval(interval); envelopeGroup.visible = false; slowZoomAndSpin(); }
    }, 16);
  }

  function slowZoomAndSpin() {

    const startT = Date.now();
    const duration = 1500;
    const startZ = cardPivotGroup.position.z;
    const endZ = 3.0;
    const startRot = Math.PI;
    const endRot = Math.PI * 2;

    const interval = setInterval(() => {
      const now = Date.now();
      const p = Math.min((now - startT) / duration, 1);
      const zoomEase = 1 - Math.pow(1 - p, 2);
      cardPivotGroup.position.z = startZ + ((endZ - startZ) * zoomEase);

      const spinStartThreshold = 0.2;
      if (p > spinStartThreshold) {
        const spinP = (p - spinStartThreshold) / (1 - spinStartThreshold);
        const s = 1.70158; const p2 = spinP - 1; const spinEase = (p2 * p2 * ((s + 1) * p2 + s) + 1);
        cardMasterGroup.rotation.y = startRot + ((endRot - startRot) * spinEase);
      }

      // 1. Trigger Burst
      // Spawn 100 individual sprites at 0.2 progress (Syncs with spin start)
      if (p > 0.2 && !spawnedBurstParticles) {
        for(let i=0; i<100; i++) {
          spawnBurstParticle();
        }
        spawnedBurstParticles = true;
      }

      // 2. Trigger Loot Rays at 0.2 progress (Syncs with spin start)
      if (p > 0.2 && !lootRaysActive) {
        lootRaysActive = true;
      }

      if (p === 1) {
        clearInterval(interval);
        cardMasterGroup.rotation.y = 0;
        currentState = STATE.CARD_CLOSED_IDLE;
        document.getElementById('instructions').innerText = "Click to read";
        document.getElementById('instructions').style.opacity = 1;
      }
    }, 16);
  }

  // --- ANIMATION LOOP ---
  let openProgress = 0;
  let currentFloatAmp = 0.05;
  let currentDimOpacity = 0; // Track background darkness
  const clock = new THREE.Clock();
  const bgDimmer = document.getElementById('bg-dimmer');

  // --- BACKGROUND SPARKLES (Behind Envelope) ---
  const bgSparkleGroup = new THREE.Group();
  // CHANGED: Added to groupAll instead of envelopeGroup.
  // This keeps them centered in the world even when the envelope drops,
  // and allows them to surround the card in 3D space.
  groupAll.add(bgSparkleGroup);

  const bgSparkles = [];
  let bgSparkleSpawnTimer = 0;

  function spawnBgSparkle() {
    const mat = new THREE.SpriteMaterial({
      map: sparkleTexture,
      transparent: true,
      opacity: 0, // Start transparent
      blending: THREE.AdditiveBlending,
      depthWrite: false,
      rotation: Math.random() * Math.PI * 2
    });

    const sprite = new THREE.Sprite(mat);

    // Random Size
    const size = 0.1 + Math.random() * 0.2;
    sprite.scale.set(size, size, 1);

    // CHANGED: Spherical Spawn Logic
    // Spawns particles in a shell/volume around the center (radius 3 to 10)
    const radius = 3 + Math.random() * 7;
    const theta = Math.random() * Math.PI * 2;      // Angle around Y
    const phi = Math.acos((Math.random() * 2) - 1); // Angle from Y

    sprite.position.set(
            radius * Math.sin(phi) * Math.cos(theta),
            radius * Math.sin(phi) * Math.sin(theta),
            radius * Math.cos(phi) // Z ranges from -radius to +radius (Front & Back)
    );

    bgSparkleGroup.add(sprite);

    bgSparkles.push({
      mesh: sprite,
      life: 0,
      maxLife: 2.0 + Math.random() * 2.0,
      targetOpacity: 0.4 + Math.random() * 0.6
    });
  }

  function updateBgSparkles(dt) {
    bgSparkleSpawnTimer += dt;
    const spawnRate = 0.2; // 5 per second
    while(bgSparkleSpawnTimer > spawnRate) {
      spawnBgSparkle();
      bgSparkleSpawnTimer -= spawnRate;
    }

    for (let i = bgSparkles.length - 1; i >= 0; i--) {
      const p = bgSparkles[i];
      p.life += dt;

      const n = p.life / p.maxLife;

      if (n >= 1) {
        bgSparkleGroup.remove(p.mesh);
        p.mesh.material.dispose();
        bgSparkles.splice(i, 1);
        continue;
      }

      let op = 0;
      if (n < 0.2) op = n * 5;
      else if (n > 0.8) op = 1.0 - ((n - 0.8) * 5);
      else op = 1.0;

      p.mesh.material.opacity = op * p.targetOpacity;

      // Gentle floating movement
      p.mesh.position.y += dt * 0.2;
      p.mesh.material.rotation += dt * 0.2;
    }
  }

  // Pre-spawn
  for(let i=0; i<20; i++) spawnBgSparkle();

  function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const timeScale = dt / 0.01667;
    const dampFactor = 0.05 * timeScale;

    // Background Dimmer Logic (Suspense & Focus)
    let targetDim = 0;

    // 1. Suspense: Darken heavily when opening the envelope
    if (currentState === STATE.OPENING_SEQUENCE) {
      targetDim = 0.75;

      // NEW: Un-darken progressively as the card spins around (PI -> 2PI)
      // This ensures the lights are back on by the time the card faces the user.
      if (cardMasterGroup.rotation.y > Math.PI + 0.01) {
        // Calculate spin progress (0.0 to 1.0)
        const spinProgress = (cardMasterGroup.rotation.y - Math.PI) / Math.PI;
        // Interpolate targetDim from 0.75 down to 0.0
        targetDim = 0.75 * (1.0 - spinProgress);
        if (targetDim < 0) targetDim = 0;
      }
    }
    // 2. Focus: Darken moderately when reading the text
    else if (currentState === STATE.CARD_OPENING || currentState === STATE.CARD_OPEN_IDLE) {
      targetDim = 0.5;
    }

    // Smoothly interpolate opacity
    currentDimOpacity += (targetDim - currentDimOpacity) * dampFactor;

    if (bgDimmer) {
      bgDimmer.style.opacity = currentDimOpacity;
    }

    if (currentState < STATE.CARD_CLOSED_IDLE) {
      groupAll.rotation.y += (targetRotY - groupAll.rotation.y) * dampFactor;
      groupAll.rotation.x += (targetRotX - groupAll.rotation.x) * dampFactor;
    } else {
      groupAll.rotation.y += (0 - groupAll.rotation.y) * dampFactor;
      groupAll.rotation.x += (0 - groupAll.rotation.x) * dampFactor;
      cardPivotGroup.rotation.y += (targetRotY - cardPivotGroup.rotation.y) * dampFactor;
      cardPivotGroup.rotation.x += (targetRotX - cardPivotGroup.rotation.x) * dampFactor;
    }

    if (currentState === STATE.CARD_OPENING || currentState === STATE.CARD_OPEN_IDLE) {
      openProgress += (1 - openProgress) * dampFactor;
      if(openProgress > 0.99) currentState = STATE.CARD_OPEN_IDLE;
    } else if (currentState === STATE.CARD_CLOSING || currentState === STATE.CARD_CLOSED_IDLE) {
      openProgress += (0 - openProgress) * dampFactor;
      if(openProgress < 0.01) currentState = STATE.CARD_CLOSED_IDLE;
    }

    const closedAngle = Math.PI - 0.05;
    const openAngle = 0;
    hingeGroup.rotation.y = closedAngle - (openProgress * (closedAngle - openAngle));

    if (currentState >= STATE.CARD_CLOSED_IDLE) {
      const closedX = 0; const openX = 0;
      const currentTargetX = closedX + (openProgress * (openX - closedX));
      cardMasterGroup.position.x += (currentTargetX - cardMasterGroup.position.x) * dampFactor;
    }

    if (currentState >= STATE.CARD_CLOSED_IDLE) {
      const baseZ = 3.0; const zoomZ = 6.0;
      const currentZ = baseZ + (openProgress * (zoomZ - baseZ));
      cardPivotGroup.position.z += (currentZ - cardPivotGroup.position.z) * dampFactor;
    }

    if (currentState >= STATE.CARD_CLOSED_IDLE) {
      let targetAmp = 0.05;
      if (currentState === STATE.CARD_OPEN_IDLE) targetAmp = 0.005;
      currentFloatAmp += (targetAmp - currentFloatAmp) * dampFactor;
      cardMasterGroup.position.y = Math.sin(Date.now() * 0.002) * currentFloatAmp;
    }

    // STAR PARTICLES (Burst)
    for (let i = burstParticles.length - 1; i >= 0; i--) {
      const p = burstParticles[i];
      p.life += dt;

      if (p.life >= p.maxLife) {
        cardPivotGroup.remove(p.mesh);
        p.mesh.material.dispose();
        burstParticles.splice(i, 1);
        continue;
      }

      p.mesh.position.addScaledVector(p.vel, timeScale);
      const friction = Math.pow(0.98, timeScale);
      p.vel.multiplyScalar(friction);

      const normalizedLife = p.life / p.maxLife;
      if (normalizedLife > 0.5) {
        p.mesh.material.opacity = 1.0 - ((normalizedLife - 0.5) * 2);
      }
    }

    // LOOT RAYS (Continuous)
    if (lootRaysActive) {
      updateLootRays(dt);
    }

    // BACKGROUND SPARKLES (Continuous)
    updateBgSparkles(dt);

    renderer.render(scene, camera);
  }

  animate();
</script>
</body>
</html>